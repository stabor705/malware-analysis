import numpy as np
from typing import List
from control_flow_graph import ControlFlowGraph

OpCode = str
Disassembly = List[OpCode]

epsilon = 1e-4

def power_iteration(W: np.ndarray, num_iterations: int) -> np.ndarray:
    # Ideally choose a random vector
    # To decrease the chance that our vector
    # Is orthogonal to the eigenvector
    x = np.random.rand(W.shape[1])
    lam_prev = 0
  
    # Iteratively improve the approximations 
    # for the largest eigenvalue and eigenvector 
    # using the power method 
    for i in range(num_iterations): 
        # Compute the updated approximation for the eigenvector 
        x = W @ x / np.linalg.norm(W @ x) 
    
        # Compute the updated approximation for the largest eigenvalue 
        lam = (x.T @ W @ x) / (x.T @ x) 
    
        # Check if the approximations have converged 
        if np.abs(lam - lam_prev) < epsilon: 
            break
    
        # Store the current approximation for the largest eigenvalue 
        lam_prev = lam 

    return lam, x

def embedGraphs(programs: List[Disassembly], num_iterations: int) -> List[np.ndarray]:
    embedded_vectors: list = []
    embedded_values:list = []
    for program in programs:
        cfg = ControlFlowGraph(program)
        eigenvalue, eigenvectors = power_iteration(cfg.matrix(), num_iterations)
        embedded_vectors.append(eigenvectors)
        embedded_values.append(eigenvalue)
    
    return embedded_values, embedded_vectors



