import requests
import concurrent.futures
import subprocess
import sys
import time
import os
from dotenv import load_dotenv

load_dotenv()

BENIGN_DIR='./androzoo/dataset/benign/'
MALWARE_DIR='./androzoo/dataset/malware/'
ANDROZOO_URL='https://androzoo.uni.lu/api/download'
API_KEY=os.getenv('ANDROZOO_API_KEY')

downloaded = 0
failures = 0

def download_file(sha, malware='True'):
    params = {
        'apikey': API_KEY,
        'sha256': sha
    }

    dest = f'{"malware" if malware == "True" else "benign"}'

    curl_command = [
        'curl', '-o', f'./androzoo/dataset/{dest}/{sha}.apk', '--remote-header-name', '-G',
        '-d', f'apikey={API_KEY}',
        '-d', f'sha256={sha}',
        ANDROZOO_URL
    ]

    try:
        start = time.time()
        print(f'Starting download of {sha}. Starting time: {start}')
        # response = requests.get(ANDROZOO_URL, params=params, stream=True)
        # response.raise_for_status()
        
        # # Use the Content-Disposition header to get the filename
        # filename = response.headers.get('Content-Disposition').split('filename=')[1]
        
        # # Write the file to disk
        # with open(filename, 'wb') as f:
        #     for chunk in response.iter_content(chunk_size=8192):
        #         f.write(chunk)

        result = subprocess.run(curl_command, check=True, capture_output=True)
        end = time.time()
        print(f"Downloaded {sha} in {end - start}.")
    except Exception as e:
        print(f"Failed to download {sha}. Reason: {e}")

def remove_failures(directory1, directory2):
    def remove_small_files(directory):
        for root, dirs, files in os.walk(directory):
            for file in files:
                file_path = os.path.join(root, file)
                if os.path.getsize(file_path) < 10240:
                    os.remove(file_path)
                    print(f"Removed {file_path}")

    remove_small_files(directory1)
    remove_small_files(directory2)

def parse_args(args):
    if len(args) < 2:
        print(f'You have to use one of the options: \'truncate\' or \'keep\'')
        sys.exit(1)
    if args[1] not in ['truncate', 'keep']:
        print(f'Fiest option has to be either \'truncate\' or \'keep\'')
        sys.exit(1)

    if args[1] == 'keep':
        return False, 0

    if args[1] == 'truncate':
        if len(args) < 3:
            print('While using truncate, specify which folder to truncate:')
            print('\t download-apks.py truncate <benign | malware | both>')
            sys.exit(1)
        if args[2] not in ['both', 'benign', 'malware']:
            print('Truncate options can only be \'both\', \'malware\' or \'benign\'')
            sys.exit(1)
        return True, args[2]
    
def truncate(type):
    if type == 'both' or type == 'benign':
        for filename in os.listdir(BENIGN_DIR):
            os.unlink(os.path.join(BENIGN_DIR, filename))

    if type == 'both' or type == 'malware':
        for filename in os.listdir(MALWARE_DIR):
            os.unlink(os.path.join(MALWARE_DIR, filename))


if __name__ == "__main__":
    if not os.path.exists('./androzoo/to_download'):
        print(f'File \'./androzoo/to_download\' does not exist!')
        sys.exit(1)

    t, type = parse_args(sys.argv)
    if t:
        truncate(type)

    sha256_list = []
    with open('./androzoo/to_download', 'r') as f:
        list = f.readlines()
        for i in list:
            sha256_list.append(i.strip().split(';'))

    with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
        # Map the download_file function to the list of SHA256 hashes
        futures = [executor.submit(download_file, sha[0], sha[1]) for sha in sha256_list]

        # Ensure all futures are completed
        for future in concurrent.futures.as_completed(futures):
            future.result()  # This will raise exceptions if any occurred during the download
    
    remove_failures(BENIGN_DIR, MALWARE_DIR)
